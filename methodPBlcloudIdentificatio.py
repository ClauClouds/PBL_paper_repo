#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jun  5 17:57:03 2020

@author: cacquist
@goal : determine cloud generated by surface induced heating/motions via LCL.
Method: the idea is to calculate LCL height for every time stamp based on pressure, 
humidity and temperature at the surface and then identify as PBL clouds only those clouds 
whose cloud base is located within z_lcl+-x%z_lcl
The method is applied between 7:00 and 18:00 
"""

import numpy as np
import matplotlib
import scipy
import pylab
import netCDF4 as nc4
import numpy.ma as ma
import matplotlib.pyplot as plt
from netCDF4 import Dataset
import struct
import glob
import pandas as pd
import datetime as dt
import random
import datetime
import matplotlib.dates as mdates
import os
import atmos
import matplotlib as mpl
import xarray as xr
from myFunctions import f_calcMeanStdVarProfiles
from myFunctions import f_plotVarianceWSingleDays
from myFunctions import f_calcWvariance
from myFunctions import f_convertPressureToHeight
from myFunctions import f_closest
from myFunctions import f_resampleArrays2StandardData
from myFunctions import f_resample2StandardData
from myFunctions import f_plotTest
from myFunctions import lcl
try:
    import cPickle as pickle
except ImportError:  # python 3.x
    import pickle
    
from matplotlib import rcParams
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['Tahoma']


# setting parameters for calculating averaging and domain size of the model:
NprofilesOut                    = 24  # hourly means
timeIncrement                   = 60  # hourly means
patch                           = 'patch003'
flagPlot                        = 0

# directories where data are stored
#path = '/Volumes/NO NAME/PBlcloudPaper/statistics/dataset_obs_model/'
pathObs                         = '/work/cacquist/HDCP2_S2/statistics/iconLemProcessed_'+patch+'/'
#'/work/cacquist/HDCP2_S2/statistics/dataset_obs_model/'
pathMod                         = '/work/cacquist/HDCP2_S2/statistics/iconLemProcessed_'+patch+'/'
pathFig                         = '/work/cacquist/HDCP2_S2/statistics/figs/'+patch+'/figures_JAMES/debugging/'
path_tower          = '/data/hatpro/jue/hdcp2/meteo_data/'#'/data/TR32/D2/data/juelich/met_mast/'
path_mwr_joyce      = '/data/hatpro/hps/data/level2/'
#path = '/work/cacquist/HDCP2_S2/statistics/dataset_obs_model/'
fileListObs                     = sorted(glob.glob(pathObs+'*.p'))
fileListMod                     = sorted(glob.glob(pathMod+'*icon_lem*.nc'))
Nfiles                          = len(fileListObs)
date_arr                        = []
LCL_obs_MWR_All = np.zeros((9600,Nfiles))
LCL_mod_All= np.zeros((9600,Nfiles))
LCL_obs_EC_All = np.zeros((9600,Nfiles))
LCL_obs_TOWER_All = np.zeros((9600,Nfiles))

def f_readingTowerData(date, PathIn):

    # reading file dat to have rel humidity data
    #filename=PathIn+'meteoFZJ'+date+'.dat'
    #array_smart = np.loadtxt(filename) # numpy Ã© intelligente e riconosce da solo che le linee che iniziano con # sono header

    # read corresponding ncdf file to have all the other variables
    ncfile = 'sups_joy_mett00_l1_any_v00_'+date+'000000.nc'
    ncData = Dataset(PathIn+ncfile, mode='r')
    #print(ncData.variables)
    # reading variables from ncdf
    datetime_tower = nc4.num2date(ncData.variables['time'][:],ncData.variables['time'].units) 
    height = ncData.variables['zag'][:].copy()
    T = ncData.variables['ta'][:].copy() # T at 6 altitudes [K]
    P = ncData.variables['pa'][:].copy() # pressure at 2m [Pa]
    Tsurf = T[:,0]
    dictOut={
        'time':datetime_tower, 
        'T':T, 
        'P':P, 
        'height':height,
        'Tsurf':Tsurf,
        'P_surf':P,
    }
    return(dictOut)



flagPlot = 1
for indFile in range(Nfiles):

    print(indFile)

    #filenameObs = '/work/cacquist/HDCP2_S2/statistics/iconLemProcessed_patch003/dataset_PBLcloudPaper_ModObs_20130506.p'
    #filenameMod = '/work/cacquist/HDCP2_S2/statistics/iconLemProcessed_patch003/icon_lem_derivedproperties20130506.nc'
    date = fileListObs[indFile][81:89]
    filenameMod = pathMod+'icon_lem_derivedproperties'+date+'.nc'
    filenameObs = pathObs+'dictionaries_ModObs_'+date+'.p'
    yy = int(date[0:4])
    mm = int(date[4:6])
    dd = int(date[6:8])

    date_arr.append(date)
        
    # opening the file containing teh LCL from the model 
    infile = open(pathObs+'dictionaries_ModObs_'+date+'.p', 'rb')
    new_dict = pickle.load(infile, encoding='latin1')
    LCL_mod = xr.Dataset({'LCL': (['time'], new_dict[4]['lclHeight'])},
                        coords = {'time': new_dict[4]['time'],
                                  'height':new_dict[4]['height']})
    # reshaping on standard time format
    timeReferenceFormat = pd.date_range(date, periods=9600, freq='9s')
    LCL_mod_reshaped = LCL_mod.reindex({"time": timeReferenceFormat}, copy=True)
    LCL_mod_All[:,indFile] = LCL_mod_reshaped.LCL.values
    ncdata = Dataset(pathMod + 'icon_lem_derivedproperties' + date + '.nc', mode='r')
    time_icon   = nc4.num2date(ncdata.groups['Temp_data'].variables['datetime_ICON'][:],\
                        ncdata.groups['Temp_data'].variables['datetime_ICON'].units)
    height_icon = ncdata.groups['Temp_data'].variables['height2'][:]
    P_icon = ncdata.groups['Temp_data'].variables['P'][:]
    T_icon = ncdata.groups['Temp_data'].variables['T'][:]
    RH_icon = ncdata.groups['Temp_data'].variables['RH'][:]
    indSurf = np.argmin(height_icon)

    PSurf_icon   = P_icon[:,indSurf]
    TSurf_icon    = T_icon[:,indSurf]
    rhSurf_icon   = RH_icon[:,indSurf-1]
    icon_dataset = xr.Dataset({'P': (['time'], PSurf_icon), 
                               'T':(['time'], TSurf_icon),
                               'RH':(['time'], rhSurf_icon)},
                        coords = {'time':time_icon})
    
    icon_dataset_reshaped = icon_dataset.reindex(time=timeReferenceFormat, copy=True)
    # -----------------------------------------------------------------------------------
    # ----reading  tower observations 
    # -----------------------------------------------------------------------------------
    pathIn   = path_tower+date[0:4]+'/'
    filename = 'sups_joy_mett00_l1_any_v00_'+date+'000000.nc'
    tower_dict     = f_readingTowerData(date, pathIn)
        # ---- process tower observations
    P_surf = tower_dict['P'][:]
    T_surf = tower_dict['Tsurf'][:]
    datetime_tower = tower_dict['time'][:]
    
    tower_dataset = xr.Dataset({'P': (['time'], P_surf), 
                                'T':(['time'], T_surf)},
                        coords = {'time':datetime_tower})
    # -----------------------------------------------------------------------------------
    # ----reading  EC stations obs
    # -----------------------------------------------------------------------------------
    EC_data = Dataset('/work/cacquist/HDCP2_S2/statistics/dataset_obs_model/meanSurface_LHSH_Fluxes_ME_RU_SE_' + date + '.nc')
    P_EC = EC_data.variables['P_MEAN_ncdf']
    T_EC = EC_data.variables['T_MEAN_ncdf']
    RH_EC = EC_data.variables['RH_MEAN_ncdf']

    time_EC = nc4.num2date(EC_data.variables['time'][:], \
                                     EC_data.variables['time'].units)
    EC_dataset = xr.Dataset({'P': (['time'], P_EC),
                             'T':(['time'], T_EC),
                             'RH':(['time'], RH_EC)},
                        coords = {'time':time_EC})
    #EC_dataset_reshaped = EC_dataset.reindex({"time": timeReferenceFormat}, copy=True)
    EC_dataset_reshaped = EC_dataset.interp_like(icon_dataset_reshaped)

    # -----------------------------------------------------------------------------------        
    # ----reading  radiometer observations 
    # -----------------------------------------------------------------------------------        
    pathIn             = path_mwr_joyce+date[2:4]+date[4:6]+'/'
    file_lwp_iwv_joyce = date[2:8]+'_hps_l2a.nc'
    file_qtprof_joyce  = date[2:8]+'_hps_l2b.nc' 
    LWP_IWV_obs_joyce = Dataset(pathIn+file_lwp_iwv_joyce, mode='r')
    QTprof_obs_joyce  = Dataset(pathIn+file_qtprof_joyce, mode='r')
    # ----- reading MWR radiometer data variables for la and lb formats
    datetime_lwp_iwv_joyce    = nc4.num2date(LWP_IWV_obs_joyce.variables['time'][:], \
                                     LWP_IWV_obs_joyce.variables['time'].units)
    RH_air                    = QTprof_obs_joyce.variables['relative_humidity'][:].copy()
    datetime_qtprof_joyce     = nc4.num2date(QTprof_obs_joyce.variables['time'][:], \
                                             QTprof_obs_joyce.variables['time'].units)
    height_qtprof_joyce       = QTprof_obs_joyce.variables['z'][:].copy() 
    T_air                     = QTprof_obs_joyce.variables['air_temperature'][:].copy()
    P_air                     = QTprof_obs_joyce.variables['air_pressure'][:].copy()
    Tsurf = T_air.data
    Psurf = P_air.data
    RHsurf = RH_air.data
    # filtering -99.
    timeSurf = datetime_qtprof_joyce[Tsurf != -99.]
    Psurf = Psurf[Tsurf != -99.]
    RHsurf = RHsurf[Tsurf != -99.]
    Tsurf = Tsurf[Tsurf != -99.]

    MWR_dataset = xr.Dataset({'P': (['time'], Psurf*100), 
                                'T':(['time'], Tsurf),
                                'RH':(['time'], RHsurf)},
                        coords = {'time':timeSurf})
    
    #reshaping datasets on standard time format
    tower_dataset_reshaped = tower_dataset.reindex({"time": timeReferenceFormat}, copy=True)
    #tower_dataset_reshaped =tower_dataset.interp_like(icon_dataset)
    
    #timeReferenceFormat = pd.date_range(date, periods=9600, freq='9s')
    MWR_dataset_reshaped = MWR_dataset.interp_like(tower_dataset_reshaped)
    #MWR_dataset_reshaped = MWR_dataset.reindex({"time": timeReferenceFormat}, copy=True)

    # calculating LCL for obs
    lcl_MWR = []
    lcl_tower = []
    lcl_EC = []
    # calculation of LCL for obs
    for itime in range(len(timeReferenceFormat)):
        P_mwr = MWR_dataset_reshaped.P.values[itime]
        T_mwr = MWR_dataset_reshaped.T.values[itime]
        rh_mwr = MWR_dataset_reshaped.RH.values[itime]/100.
        T_tower = tower_dataset_reshaped.T.values[itime]
        P_tower = tower_dataset_reshaped.P.values[itime]
        rh_EC = EC_dataset_reshaped.RH.values[itime]
        T_EC = EC_dataset_reshaped.T.values[itime]
        P_EC = EC_dataset_reshaped.P.values[itime]*100.

        if ~np.isnan(P_mwr) *  ~np.isnan(T_mwr) *  ~np.isnan(rh_mwr):
            lcl_MWR.append(lcl(P_mwr,T_mwr,rh_mwr)) ## - p in Pascals
                                                        # - T in Kelvins
                                                        # - Exactly one of rh, rhl, and rhs (dimensionless, from 0 to 1)
        else:
            lcl_MWR.append(np.nan)
            
        if ~np.isnan(P_tower) *  ~np.isnan(T_tower) *  ~np.isnan(rh_mwr):
            lcl_tower.append(lcl(P_tower,T_tower,rh_mwr))
        else:
            lcl_tower.append(np.nan)

        if ~np.isnan(P_EC) *  ~np.isnan(T_EC) *  ~np.isnan(rh_EC):
            lcl_EC.append(lcl(P_EC,T_EC,rh_EC))
        else:
            lcl_EC.append(np.nan)

    LCL_obs_EC_All[:,indFile] = lcl_EC
    LCL_obs_MWR_All[:,indFile] = lcl_MWR
    LCL_obs_TOWER_All[:,indFile] = lcl_tower


    if flagPlot == 1:
        fig, ax = plt.subplots(nrows=4, ncols=1, figsize=(12,8))
        fontSizeTitle = 12
        fontSizeX = 10
        fontSizeY = 10
        fontSizeCbar = 10
        labelsizeaxes = 10
        from matplotlib import rcParams
        plt.gcf().subplots_adjust(bottom=0.15)
        matplotlib.rc('xtick', labelsize=labelsizeaxes)  # sets dimension of ticks in the plots
        matplotlib.rc('ytick', labelsize=labelsizeaxes)  # sets dimension of ticks in the plots
        rcParams['font.family'] = 'sans-serif'
        rcParams['font.sans-serif'] = ['Tahoma']
        ax[0] = plt.subplot(4,1,1)  
        ax[0].spines["top"].set_visible(False)  
        ax[0].spines["right"].set_visible(False)  
        ax[0].get_xaxis().tick_bottom()  
        ax[0].get_yaxis().tick_left() 
        #ax[0].set_xlim(-100., 450.)
        #ax[0].set_ylim(-100., 450.)
        ax[0].set_xlabel('time [hh:mm]', fontsize=16)
        ax[0].set_ylabel('T_surf [K]', fontsize=16)
        ax[0].grid(b=True, which='major', color='#666666', linestyle=':')
        ax[0].plot(tower_dataset_reshaped.time.values, tower_dataset_reshaped.T.values, 'o', label='Tower', color='black')
        ax[0].plot(MWR_dataset_reshaped.time.values, MWR_dataset_reshaped.T.values, label='MWR', color='blue')
        ax[0].plot(icon_dataset_reshaped.time.values, icon_dataset_reshaped.T.values, label='model', color='red')
        ax[0].plot(EC_dataset_reshaped.time.values, EC_dataset_reshaped.T.values, label='EC stat', color='green')

        ax[1] = plt.subplot(4,1,2)  
        ax[1].spines["top"].set_visible(False)  
        ax[1].spines["right"].set_visible(False)  
        ax[1].get_xaxis().tick_bottom()  
        ax[1].get_yaxis().tick_left() 
        #ax[0].set_xlim(-100., 450.)
        #ax[0].set_ylim(-100., 450.)
        ax[1].set_xlabel('time [hh:mm]', fontsize=16)
        ax[1].set_ylabel('P_surf [Pa]', fontsize=16)
        ax[1].grid(b=True, which='major', color='#666666', linestyle=':')
        ax[1].plot(tower_dataset_reshaped.time.values, tower_dataset_reshaped.P.values, 'o', label='Tower', color='black')
        ax[1].plot(MWR_dataset_reshaped.time.values, MWR_dataset_reshaped.P.values, label='MWR', color='blue')
        ax[1].plot(icon_dataset_reshaped.time.values, icon_dataset_reshaped.P.values, label='model', color='red')
        ax[1].plot(EC_dataset_reshaped.time.values, EC_dataset_reshaped.P.values*100., label='EC stat', color='green')


        ax[2] = plt.subplot(4,1,3)  
        ax[2].spines["top"].set_visible(False)  
        ax[2].spines["right"].set_visible(False)  
        ax[2].get_xaxis().tick_bottom()  
        ax[2].get_yaxis().tick_left() 
        #ax[0].set_xlim(-100., 450.)
        #ax[0].set_ylim(-100., 450.)
        ax[2].set_xlabel('time [hh:mm]', fontsize=16)
        ax[2].set_ylabel('RH [%]', fontsize=16)
        ax[2].grid(b=True, which='major', color='#666666', linestyle=':')
        ax[2].plot(MWR_dataset_reshaped.time.values, MWR_dataset_reshaped.RH.values, label='MWR', color='blue')
        ax[2].plot(icon_dataset_reshaped.time.values, icon_dataset_reshaped.RH.values, label='model', color='red')
        ax[2].plot(EC_dataset_reshaped.time.values, EC_dataset_reshaped.RH.values*100., label='EC stat', color='green')

       
        ax[3] = plt.subplot(4,1,4)  
        ax[3].spines["top"].set_visible(False)  
        ax[3].spines["right"].set_visible(False)  
        ax[3].get_xaxis().tick_bottom()  
        ax[3].get_yaxis().tick_left() 
        ax[3].set_xlabel('time [hh:mm]', fontsize=16)
        ax[3].set_ylabel('LCL height [Pa]', fontsize=16)
        ax[3].grid(b=True, which='major', color='#666666', linestyle=':')
        ax[3].plot(timeReferenceFormat, lcl_tower, 'o', label='Tower', color='black')
        ax[3].plot(timeReferenceFormat, lcl_MWR, label='MWR', color='blue')
        ax[3].plot(timeReferenceFormat, LCL_mod_reshaped.LCL.values, label='model', color='red')
        ax[3].plot(timeReferenceFormat, lcl_EC, label='EC stat', color='green')

        ax[3].legend(frameon=False)
        
        fig.tight_layout()
        plt.savefig(pathFig +date+ '_P_T_LCL_comparison.png', format='png')
        
#%%
# saving LCL dataset in xarray for all days together
LCL_dataset = xr.Dataset({'LCL_EC': (['time','Nfiles'], LCL_obs_EC_All),
                          'LCL_MWR': (['time','Nfiles'], LCL_obs_MWR_All),
                          'LCL_ICONLEM': (['time','Nfiles'], LCL_mod_All),
                          'LCL_TOWER': (['time','Nfiles'], LCL_obs_TOWER_All)},
                        coords = {'time':EC_dataset_reshaped.time.values,
                                  'height':height_icon,
                                  'Nfiles':date_arr})
LCL_dataset.to_netcdf(path=pathObs+'LCL_Mod_obs_allDataset.nc', mode='w')


#.to_netcdf(self, path=None, mode: str = 'w', format: str = None, group: str = None, engine: str = None, encoding: Mapping = None, unlimited_dims: Iterable[Hashable] = None, compute: bool = True, invalid_netcdf: bool = False) â Union[bytes, ForwardRef('Delayed'), NoneType]
# multipanel plot with 22 days: LCL comparison for all

fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8,6))
Ncols = 1
Nrows = 22
Nplots = 22
fontSizeTitle = 12
fontSizeX = 10
fontSizeY = 10
fontSizeCbar = 10
labelsizeaxes = 10
from matplotlib import rcParams

matplotlib.rc('xtick', labelsize=labelsizeaxes)  # sets dimension of ticks in the plots
matplotlib.rc('ytick', labelsize=labelsizeaxes)  # sets dimension of ticks in the plots
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['Tahoma']
fig, ax = plt.subplots(nrows=Nrows, ncols=Ncols, figsize=(10, 30))
plt.gcf().subplots_adjust(bottom=0.15)
##ymax = 2500.
#ymin = 107.
for indPlot in range(Nplots):
    indAx = indPlot+1
    ax = plt.subplot(Nrows, Ncols,indAx)
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%H:%M"))
    ax.xaxis.set_minor_formatter(mdates.DateFormatter("%H:%M"))
    ax.xaxis_date()
    ax.set_title(date_arr[indPlot])
    ax.plot(timeReferenceFormat,LCL_mod_All[:,indPlot], label='model', color='red')
    ax.plot(timeReferenceFormat,LCL_obs_MWR_All[:,indPlot], label='obs-MWR', color='black')
    ax.plot(timeReferenceFormat,LCL_obs_EC_All[:,indPlot], label='obs_ECstat', color='green')
    ax.set_xlabel('time [hh:mm]', fontsize=fontSizeX)
    ax.set_ylabel('LCL height [m]', fontsize=fontSizeY)
    if indPlot == Nplots-1:
        ax.legend(frameon=False)

fig.tight_layout()
plt.savefig(pathFig + 'all_LCL_obs_mod_timeSeries.png', format='png')

# =============================================================================
# Thermodyn_cosmo, Thermodyn_iconlem, Thermodyn_obs:  index 4, 5, 6
# =============================================================================
# 
#     ThermodynPar={'mixingRatio':r, 
#                   'relativeHumidity':rh, 
#                   'virtualTemperature':tv,
#                   'cclHeight':result_ccl['z_ccl'],
#                   'cclTemperature':result_ccl['T_ccl'],
#                   'lclHeight':lclArray,
#                   'surfaceTemperature':TSurf, 
#                   'virtualPotentialTemperature':Theta_v,
#                   'potentialTemperature':Theta,
#                   'time': time,
#                   'height':height,
#                   'LTS':LTS,
#                   }